package v1beta1_test

import (
	"fmt"
	fake "github.com/brianvoe/gofakeit/v5"
	"github.com/grafeas/grafeas/proto/v1beta1/build_go_proto"
	"github.com/grafeas/grafeas/proto/v1beta1/common_go_proto"
	"github.com/grafeas/grafeas/proto/v1beta1/grafeas_go_proto"
	"github.com/grafeas/grafeas/proto/v1beta1/package_go_proto"
	"github.com/grafeas/grafeas/proto/v1beta1/vulnerability_go_proto"
	. "github.com/onsi/gomega"
	"github.com/rode/grafeas-elasticsearch/test/util"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"testing"
)

func TestNote(t *testing.T) {
	Expect := util.NewExpect(t)
	s := util.NewSetup()

	// setup project for occurrences
	projectName := util.RandomProjectName()

	_, err := util.CreateProject(s, projectName)
	Expect(err).ToNot(HaveOccurred())

	t.Run("creating a note", func(t *testing.T) {
		// generate note ID (note IDs are provided by client, not generated by server)
		noteId := fake.UUID()

		t.Run("should be successful", func(t *testing.T) {
			expectedNote, err := s.Gc.CreateNote(s.Ctx, &grafeas_go_proto.CreateNoteRequest{
				Parent: projectName,
				NoteId: noteId,
				Note:   createFakeBuildNote(),
			})
			Expect(err).ToNot(HaveOccurred())

			actualNote, err := s.Gc.GetNote(s.Ctx, &grafeas_go_proto.GetNoteRequest{Name: expectedNote.GetName()})
			Expect(err).ToNot(HaveOccurred())

			Expect(actualNote).To(Equal(expectedNote))
		})
	})

	t.Run("batch creating notes", func(t *testing.T) {
		noteId1 := fake.UUID()
		noteId2 := fake.UUID()

		t.Run("should be successful", func(t *testing.T) {
			bo, err := s.Gc.BatchCreateNotes(s.Ctx, &grafeas_go_proto.BatchCreateNotesRequest{
				Parent: projectName,
				Notes: map[string]*grafeas_go_proto.Note{
					noteId1: createFakeBuildNote(),
					noteId2: createFakeVulnerabilityNote(),
				},
			})
			Expect(err).ToNot(HaveOccurred())

			for _, o := range bo.Notes {
				_, err = s.Gc.GetNote(s.Ctx, &grafeas_go_proto.GetNoteRequest{Name: o.GetName()})
				Expect(err).ToNot(HaveOccurred())
			}

			t.Run("should not create notes with duplicate IDs", func(t *testing.T) {
				noteId3 := fake.UUID()

				// this will return an error, but one of the notes should have still been created
				_, err := s.Gc.BatchCreateNotes(s.Ctx, &grafeas_go_proto.BatchCreateNotesRequest{
					Parent: projectName,
					Notes: map[string]*grafeas_go_proto.Note{
						noteId1: createFakeBuildNote(),
						noteId3: createFakeVulnerabilityNote(),
					},
				})
				Expect(err).To(HaveOccurred())

				_, err = s.Gc.GetNote(s.Ctx, &grafeas_go_proto.GetNoteRequest{
					Name: fmt.Sprintf("%s/notes/%s", projectName, noteId3),
				})
				Expect(err).ToNot(HaveOccurred())
			})
		})
	})

	t.Run("deleting a note", func(t *testing.T) {
		noteId := fake.UUID()

		n, err := s.Gc.CreateNote(s.Ctx, &grafeas_go_proto.CreateNoteRequest{
			Parent: projectName,
			NoteId: noteId,
			Note:   createFakeBuildNote(),
		})
		Expect(err).ToNot(HaveOccurred())

		// Currently Grafeas returns an error even on successful delete.
		// This makes testing delete scenarios awkward.
		// For now we ignore response on delete, and check for error on a subsequent lookup, assuming it won't be found.
		//
		// TODO: Once a new version of Grafeas is released that contains this fix:
		//  https://github.com/grafeas/grafeas/pull/456
		//  This should be updated to actually review delete results

		_, _ = s.Gc.DeleteNote(s.Ctx, &grafeas_go_proto.DeleteNoteRequest{
			Name: n.GetName(),
		})

		_, err = s.Gc.GetNote(s.Ctx, &grafeas_go_proto.GetNoteRequest{
			Name: n.GetName(),
		})
		Expect(err).To(HaveOccurred())
		Expect(status.Code(err)).To(Equal(codes.NotFound))
	})
}

func createFakeBuildNote() *grafeas_go_proto.Note {
	return &grafeas_go_proto.Note{
		Name:             fake.LetterN(10),
		ShortDescription: fake.LoremIpsumSentence(fake.Number(5, 10)),
		LongDescription:  fake.LoremIpsumSentence(fake.Number(5, 10)),
		Kind:             common_go_proto.NoteKind_BUILD,
		Type: &grafeas_go_proto.Note_Build{
			Build: &build_go_proto.Build{
				BuilderVersion: fake.LetterN(10),
				Signature: &build_go_proto.BuildSignature{
					PublicKey: fake.LetterN(10),
					KeyId:     fake.LetterN(10),
					Signature: []byte(fake.LetterN(10)),
				},
			},
		},
	}
}

func createFakeVulnerabilityNote() *grafeas_go_proto.Note {
	return &grafeas_go_proto.Note{
		Name:             fake.LetterN(10),
		ShortDescription: fake.LoremIpsumSentence(fake.Number(5, 10)),
		LongDescription:  fake.LoremIpsumSentence(fake.Number(5, 10)),
		Kind:             common_go_proto.NoteKind_VULNERABILITY,
		Type: &grafeas_go_proto.Note_Vulnerability{
			Vulnerability: &vulnerability_go_proto.Vulnerability{
				Details: []*vulnerability_go_proto.Vulnerability_Detail{
					{
						Package: fake.LetterN(10),
						CpeUri:  fake.LetterN(10),
						MinAffectedVersion: &package_go_proto.Version{
							Name: fake.AppVersion(),
							Kind: package_go_proto.Version_NORMAL,
						},
					},
				},
			},
		},
	}
}
